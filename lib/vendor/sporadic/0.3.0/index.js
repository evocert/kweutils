var sporadic=function(e){"use strict";var r={defer:()=>{const e={},r={changed:!1};return r.promise=new Promise((r,t)=>{e.resolve=r,e.reject=t}),r.resolve=(t=>{r.changed||(r.changed=!0,e.resolve(t))}),r.reject=(t=>{r.changed||(r.changed=!0,e.reject(t))}),r},resolved:e=>new Promise(r=>r(e)),rejected:e=>new Promise((r,t)=>t(e))};let t=null;t=(e=>{const{promise:n,resolve:s,reject:o}=r.defer(),c=n.then(()=>t(e));return{current:n,next:c,resolve:s,reject:o,produced:!1,broken:!1,finalizer:e}});const n=async e=>{return{current:await e.current,next:await e.next}},s=async e=>{let r=e;for(;r.produced&&!r.broken;)r=await r.next;return{point:r}},o=async(e,r)=>{const{point:t}=await s(e);return t.resolve(r),t.produced=!0,await t.next},c=async e=>{const{point:r}=await s(e);if(r.broken)await r.next;else{r.reject((()=>Error("Stream is closed!"))()),r.produced=!0,r.broken=!0;try{r.finalizer&&r.finalizer()}catch(e){}await r.next}},l=e=>c(e).catch(()=>{}),a=async(e,t)=>{const s=r.defer();let o=e;try{for(;;){const e=await n(o);o=e.next;try{t(e.current)}catch(e){throw s.reject(e),e}}}catch(e){s.resolve(!0)}return await s.promise};const i=()=>Error("Channel is closed!");let d=null,u=null;var h={open:e=>r.resolved(t(e)),push:o,pull:n,close:c,react:a,filter:async(e,r)=>{const n=t();let s=n;return a(e,e=>{try{r(e)&&o(s,e).then(e=>{s=e}).catch(e=>{l(s)})}catch(e){l(s)}}).then(()=>{l(s)}),n},map:async(e,r)=>{const n=t();let s=n;return a(e,e=>{try{o(s,r(e)).then(e=>{s=e}).catch(e=>{l(s)})}catch(e){l(s)}}).then(()=>{l(s)}),n},every:e=>{let n=null;const s=t(()=>n());let c=s;const l=setInterval(()=>{o(c,!0).then(e=>{c=e})},e);return n=(()=>{clearInterval(l)}),r.resolved(s)}},f={open:()=>r.resolved((()=>{const e={demands:[],supplies:[]};return e.closed=r.defer(),e.isClosed=!1,e})()),send:d=((e,t,n)=>{if(0===e.demands.length){if(e.isClosed)return r.rejected(i());const s=r.defer();return null!=n&&"number"==typeof n&&n>=1&&setTimeout(()=>{s.resolve(!1)},Math.floor(n)),e.supplies.push({received:s,message:t}),s.promise}{let n=e.demands.shift();for(;e.demands.length>0&&n.changed;)n=e.demands.shift();return n.changed?d(e,t):(n.resolve(t),r.resolved(!0))}}),receive:u=((e,t)=>{if(0===e.supplies.length){if(e.isClosed)return r.rejected(i());const n=r.defer();return e.demands.push(n),null!=t&&"number"==typeof t&&t>=0&&setTimeout(()=>{n.reject((()=>Error("Timeout while listening channel!"))())},Math.floor(t)),n.promise}{let n=e.supplies.shift();for(;e.supplies.length>0&&n.received.changed;)n=e.supplies.shift();return n.received.changed?u(e,t):(n.received.resolve(!0),r.resolved(n.message))}}),close:e=>e.isClosed?r.resolved(!1):(e.isClosed=!0,(e=>{for(;0!==e.demands.length;)e.demands.shift().reject(i())})(e),e.closed.resolve(!0),r.resolved(!0)),closed:e=>e.closed.promise,sendAfter:(e,r,t,n)=>new Promise((s,o)=>{setTimeout(()=>{d(r,t,n).then(s,o)},Math.floor(Math.max(0,e)))}),receiveAfter:(e,r,t)=>new Promise((n,s)=>{setTimeout(()=>{u(r,t).then(n,s)},Math.floor(Math.max(0,e)))})},p={streams:h,channels:f};return e.default=p,e.streams=h,e.channels=f,e}({});